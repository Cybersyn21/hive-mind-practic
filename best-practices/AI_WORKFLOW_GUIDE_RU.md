# Руководство по работе с AI-агентами: Лучшие практики от Константина Дяченко

> **Целевая аудитория**: Разработчики и не-программисты, работающие с AI-агентами (Hive Mind, Agent, Agent-Commander, ClaudeCode)
>
> **Версия**: 1.0.0
> **Дата**: Декабрь 2025

---

## Оглавление

1. [Введение](#1-введение)
2. [Философия работы с AI-агентами](#2-философия-работы-с-ai-агентами)
3. [Подготовка репозитория для работы с AI](#3-подготовка-репозитория-для-работы-с-ai)
4. [Написание эффективных GitHub Issues](#4-написание-эффективных-github-issues)
5. [Трехэтапный процесс решения задач](#5-трехэтапный-процесс-решения-задач)
6. [Case Study подход](#6-case-study-подход)
7. [Отладка и диагностика](#7-отладка-и-диагностика)
8. [Работа с историей и данными](#8-работа-с-историей-и-данными)
9. [Фактчекинг и верификация](#9-фактчекинг-и-верификация)
10. [Универсальные промпты](#10-универсальные-промпты)

---

## 1. Введение

Это руководство содержит структурированную выжимку идей и лучших практик автора проекта Hive Mind — Константина Дяченко. Цель документа — помочь пользователям эффективно организовывать проекты и ставить задачи AI-ботам для написания документации, кода и решения проблем.

### Ключевая идея

> "С агентом нужно настроить симбиоз, как сработать с коллегой."

AI-агент — это не волшебная палочка, а партнер, которому нужно:
- Предоставить все данные как есть
- Позволить "увидеть" и "услышать" то же самое, что и вы
- Дать время на анализ и итерации

---

## 2. Философия работы с AI-агентами

### 2.1 Принцип консенсуса

> "Когда и человек и AI исходят из одного и того же набора фактов, событий — вероятность прийти к консенсусу выше."

**Практическое применение:**
- Всегда делитесь полным контекстом проблемы
- Прикладывайте логи, скриншоты, примеры кода
- Описывайте ожидаемое поведение vs. фактическое

### 2.2 Консенсус системы

> "Когда баг исправлен — фактически вы привели к консенсусу всю систему — и себя, и AI, и код. Ожидания стали согласованы с алгоритмом действий."

**Что это означает:**
- Цель — не просто "починить код", а синхронизировать понимание между человеком, AI и кодовой базой
- Успешное решение = все три стороны "говорят" одинаково

### 2.3 Терпение и упорство

> "Всё это требует терпения и упорства. Но если не сильно принимать всё близко к сердцу, просто знать, что рано или поздно оно будет исправлено."

**Рекомендации:**
- Не ожидайте идеального решения с первой попытки
- Планируйте итерации
- Каждая неудачная попытка — это данные для следующей

---

## 3. Подготовка репозитория для работы с AI

### 3.1 Структура файлов

**Ограничение размера файлов:**
```
Максимум 1500 строк на файл кода
```

> "Размер в 1500 строк важен для файлов с кодом, чтобы убедиться, что файл с кодом читается целиком."

**Примечание:** Это ограничение не относится к логам — AI может читать логи любого размера.

### 3.2 Принципы чистого кода

| Принцип | Описание |
|---------|----------|
| **SOLID** | Single responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion |
| **DRY** | Don't Repeat Yourself — избегайте дублирования кода |
| **Clean Code** | Читаемый, понятный код |
| **Self-documenting code** | Код, который объясняет сам себя через именование |

### 3.3 Документация кода

**JSDoc для публичных функций:**
```javascript
/**
 * Выполняет bash-команду и возвращает результат
 *
 * @param {string} command - Команда для выполнения
 * @param {Object} options - Опции выполнения
 * @param {number} [options.timeout=120000] - Таймаут в миллисекундах
 * @returns {Promise<Object>} Результат с stdout, stderr, exitCode
 * @throws {Error} При ошибке выполнения или таймауте
 * @example
 * const result = await executeBash('ls -la', { cwd: '/tmp' });
 * @since 1.0.0
 */
async function executeBash(command, options) {
  // ...
}
```

### 3.4 Автоматизация и CI/CD

**Обязательные проверки в GitHub Actions:**
- Автоматизированные тесты
- Проверки на компилируемость
- Линтеры (проверка качества кода)
- Проверки безопасности
- Проверка размера файлов

**Пример проверки размера файлов:**
```bash
find src/ -name "*.js" -exec wc -l {} + | awk '$1 > 1500 {print "ERROR: " $2 " превышает 1500 строк"}'
```

### 3.5 Verbose/Debug режим

> "Во всех своих проектах я теперь --verbose или --debug режим всшиваю намертво. Чтобы всегда можно было увидеть полный трейс того что происходит по логам. И ни один баг ещё не устоял перед этим."

**Рекомендации:**
```javascript
// В каждом модуле
const DEBUG = process.env.DEBUG === 'true';

function log(...args) {
  if (DEBUG) {
    console.log('[DEBUG]', new Date().toISOString(), ...args);
  }
}
```

---

## 4. Написание эффективных GitHub Issues

### 4.1 Структура хорошего Issue

```markdown
## Заголовок: [Конкретное действие] + [что] + [где]

## Описание
[Чёткое объяснение того, чего нужно достичь]

## Исходные данные
- Расположение: [точный путь]
- Формат: [тип файлов]
- Количество: [число или "все файлы"]

## Требования
- [Конкретное требование 1]
- [Конкретное требование 2]
- [Требования к качеству]

## Ожидаемый результат
- Формат: [целевой формат]
- Расположение: [путь вывода]
- Именование: [правила именования]

## Критерии успеха
- [Как проверить успех]
```

### 4.2 Примеры хороших и плохих Issues

**Хороший пример:**
```
Заголовок: Конвертировать все PNG в WEBP в папке /assets

Описание:
Конвертировать все PNG изображения в /assets/images в WEBP.

Требования:
- Сохранить оригинальное качество
- Создать бэкап в /assets/images/originals
- Сгенерировать отчёт об экономии размера

Критерии успеха: Все файлы конвертированы, отчёт создан
```

**Плохой пример:**
```
Заголовок: Конвертировать изображения
Описание: У меня есть изображения, пожалуйста конвертируйте их
```

### 4.3 Почему плохие Issues не работают

| Проблема | Последствие |
|----------|-------------|
| Не указан формат | AI не знает во что конвертировать |
| Нет расположения | AI не знает где искать файлы |
| Нет требований к качеству | Результат может быть неприемлемым |
| Слишком расплывчато | AI потратит токены на уточнения |

---

## 5. Трехэтапный процесс решения задач

> "Идеально иметь три этапа для каждой задачи, особенно если задача очень сложная"

### 5.1 Этап 1: Глубокий анализ

**Цель:** Полностью понять проблему перед написанием кода

**Промпт для запуска анализа:**
```
Please download all logs and data related about the issue to this repository,
make sure we compile that data to `./docs/case-studies/issue-{id}` folder,
and use it to do deep case study analysis (also make sure to search online
for additional facts and data), in which we will reconstruct timeline/sequence
of events, find root causes of the problem, and propose possible solutions.
```

**Результат этапа:**
- Документ case study с анализом
- Хронология событий
- Выявленные первопричины
- Предложенные варианты решений

### 5.2 Этап 2: Написание тестов по TDD

**Цель:** Зафиксировать требования в виде тестов до написания кода

**Принципы:**
1. Напишите тест, который падает (RED)
2. Тест описывает ожидаемое поведение
3. Тест — это исполняемая спецификация

**Пример:**
```javascript
describe('ConvertImage', () => {
  it('should convert PNG to WEBP preserving quality', async () => {
    const result = await convertImage('test.png', 'webp');
    expect(result.format).toBe('webp');
    expect(result.quality).toBeGreaterThan(90);
  });

  it('should create backup of original file', async () => {
    await convertImage('test.png', 'webp');
    expect(fs.existsSync('originals/test.png')).toBe(true);
  });
});
```

### 5.3 Этап 3: Написание решения к тестам

**Цель:** Написать код, который проходит все тесты

**Преимущества:**
- Код точно соответствует требованиям
- Есть автоматическая проверка корректности
- Легче рефакторить в будущем

---

## 6. Case Study подход

### 6.1 Что такое Case Study

Case Study — это глубокий анализ проблемы с документированием:
- Хронологии событий
- Первопричин
- Предложенных решений
- Принятого решения и его результатов

### 6.2 Структура папки case-studies

```
docs/
└── case-studies/
    ├── issue-123/
    │   ├── README.md          # Обзор проблемы
    │   ├── TIMELINE.md        # Хронология событий
    │   ├── ROOT-CAUSE.md      # Анализ первопричин
    │   ├── SOLUTIONS.md       # Предложенные решения
    │   └── logs/              # Собранные логи
    │       ├── ci-run-456.log
    │       └── error-trace.txt
    └── issue-456/
        └── ...
```

### 6.3 Универсальный промпт для Case Study

**Базовый:**
```
Please do detailed case study as we usually do, download logs from the
pull request, reconstruct timeline of events, find root causes of the
problem, and propose possible solutions.
```

**Расширенный:**
```
Please download all logs and data related about the issue to this repository,
make sure we compile that data to `./docs/case-studies/issue-{id}` folder,
and use it to do deep case study analysis (also make sure to search online
for additional facts and data), in which we will reconstruct timeline/sequence
of events, find root causes of the problem, and propose possible solutions.
```

### 6.4 Преимущества Case Study подхода

> "Мне не нужно думать в чём проблема — он сам разбирается и предлагает решения. Мне потом остаётся только выбрать вариант решения после его детального анализа."

| Преимущество | Описание |
|--------------|----------|
| **Экономия времени** | AI делает рутинный анализ |
| **Полнота** | Ничего не упущено |
| **Документация** | История решений сохраняется |
| **Обучение** | База знаний для будущих проблем |

---

## 7. Отладка и диагностика

### 7.1 Предоставление данных AI

> "Достаточно AI предоставить все данные как есть. Нужно чтобы он 'увидел', 'услышал' то же самое что и ты."

**Что нужно предоставить:**
- Полные логи (не обрезанные)
- Скриншоты ошибок
- Цифровые данные (коды ошибок, метрики)
- Контекст: что делали до ошибки

### 7.2 Цифровые данные vs. Скриншоты

> "Я ему пытался картинки ошибок отдавать, но это прям лажа. А вот когда пошли цифры ошибок реальных, то сразу AI зашевелился."

**Рекомендация:**
- Скриншоты + цифровые данные вместе — лучший вариант
- Только скриншоты — менее эффективно
- Только цифры — хорошо работает

### 7.3 Verbose режим в проектах

**Как внедрить:**

```javascript
// config/debug.js
export const DEBUG_MODE = process.env.DEBUG === 'true';
export const VERBOSE_MODE = process.env.VERBOSE === 'true';

export function trace(module, message, data = {}) {
  if (VERBOSE_MODE) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      module,
      message,
      ...data
    }));
  }
}
```

**Использование:**
```javascript
import { trace } from './config/debug.js';

async function processFile(path) {
  trace('processFile', 'Starting', { path });

  try {
    const result = await doWork(path);
    trace('processFile', 'Completed', { path, result });
    return result;
  } catch (error) {
    trace('processFile', 'Error', { path, error: error.message });
    throw error;
  }
}
```

---

## 8. Работа с историей и данными

### 8.1 Принцип "Add Only" истории

> "История должна быть add only (только дополняемая) и её прошлое должно быть immutable (неизменяемое)."

**Практические правила:**
- **Не удаляйте Issues** — закрывайте их
- **Не редактируйте историю** — добавляйте комментарии
- **Не удаляйте Pull Requests** — закрывайте и документируйте причину

### 8.2 Почему это важно

> "Одна правка истории задним числом создаёт необходимость во всех форках и других местах вносить такие же правки."

**Риски изменения истории:**
- Потеря данных при работе нескольких исполнителей
- Повреждение синхронизации с форками
- Утрата контекста решений

### 8.3 Ценность архивных данных

> "Хорошо оформленное issue с решением сегодня может спасти десятки часов кому-то в будущем, и таких людей могут быть миллионы."

**Преимущества сохранения истории:**
- Данные для обучения AI будущего
- Справочник для других разработчиков
- Вклад в фундамент знаний человечества

### 8.4 Где хранить данные

> "Лучше не вставлять всё целиком, а выложить на GitHub в репозиторий или в GitHub Gist публично."

**Рекомендации:**
- Большие логи → GitHub Gist
- Структурированные данные → Отдельные файлы в репозитории
- Временные данные → `./docs/case-studies/`

---

## 9. Фактчекинг и верификация

### 9.1 Процесс фактчекинга

> "Фактчекинг проводится так: 1) Из текста выделяется список утверждений. 2) Каждое утверждение проверяется. 3) Если это факт о коде, должна быть цитата или ссылка на код."

**Алгоритм:**

```
1. Выделить список утверждений из текста AI
2. Для каждого утверждения:
   - Если утверждение о коде → найти цитату из кода
   - Если утверждение о системе → найти документацию
   - Если утверждение о данных → найти источник данных
3. Помечать непроверенные утверждения как "требует верификации"
```

### 9.2 Верификация утверждений о коде

**Хороший пример:**
```
Утверждение: "Функция processFile находится в файле utils.js на строке 42"
Верификация: ✅ src/utils.js:42 содержит `function processFile(`
```

**Плохой пример:**
```
Утверждение: "Код обрабатывает ошибки корректно"
Верификация: ❌ Нет конкретной ссылки на код
```

### 9.3 Важность раннего обнаружения ошибок

> "Если модель строит свои рассуждения на ложных фактах, то все дальнейшие выводы на основе ложных фактов будут тоже ложными. Поэтому чем раньше ложный факт будет обнаружен, тем лучше."

---

## 10. Универсальные промпты

### 10.1 Промпт для глубокого анализа проблемы

```
Please download all logs and data related about the issue to this repository,
make sure we compile that data to `./docs/case-studies/issue-{id}` folder,
and use it to do deep case study analysis (also make sure to search online
for additional facts and data), in which we will reconstruct timeline/sequence
of events, find root causes of the problem, and propose possible solutions.
```

### 10.2 Промпт для анализа Pull Request

```
Please do detailed case study as we usually do, download logs from the
pull request, reconstruct timeline of events, find root causes we got
pull request not linked to original issue, and propose possible solutions.
```

### 10.3 Промпт для рефакторинга модуля

```
Please analyze this module, identify code smells and violations of
SOLID/DRY principles, and propose refactoring steps to make it more
logical and readable. Provide specific code examples for each suggestion.
```

### 10.4 Промпт для написания документации

```
Analyze the codebase in [directory], understand its structure and
functionality, and create comprehensive documentation including:
1. Project overview and purpose
2. Installation instructions
3. Usage examples for all public APIs
4. Configuration options
5. Troubleshooting guide

Output in [language] with code examples that work.
```

### 10.5 Промпт для TDD

```
Based on these requirements:
[requirements]

Write comprehensive unit tests that:
1. Cover all edge cases
2. Test error handling
3. Use descriptive test names
4. Include setup and teardown where needed

Do NOT write implementation code yet - only tests.
```

---

## Приложение A: Чеклист подготовки репозитория

- [ ] Файлы кода не превышают 1500 строк
- [ ] Настроен CI/CD с автоматическими проверками
- [ ] Все публичные функции имеют JSDoc
- [ ] Внедрен --verbose/--debug режим
- [ ] Создана структура docs/case-studies/
- [ ] Настроены линтеры и форматтеры
- [ ] Есть CONTRIBUTING.md с правилами
- [ ] Тесты покрывают основную функциональность

## Приложение B: Чеклист написания Issue

- [ ] Заголовок конкретный и понятный
- [ ] Описание содержит контекст
- [ ] Указано точное расположение файлов
- [ ] Перечислены конкретные требования
- [ ] Определены критерии успеха
- [ ] Приложены логи/скриншоты (если применимо)
- [ ] Указан ожидаемый результат

## Приложение C: GitHub Flow для работы с AI

1. **Создать ветку** для каждой задачи
2. **Сделать изменения** в этой ветке
3. **Коммитить атомарно** — каждый коммит = одно логическое изменение
4. **Создать Pull Request** с описанием
5. **Получить review** (от человека или AI)
6. **Слить PR** после одобрения
7. **Удалить ветку** после слияния

---

*Документ создан на основе диалогов и практик Константина Дяченко, автора проекта Hive Mind.*
